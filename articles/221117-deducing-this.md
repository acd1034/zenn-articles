---
title: ã€C++23ã€‘ã‚¯ãƒ©ã‚¹ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆãƒ‘ãƒ©ãƒ¡ã‚¿ã®æ˜ç¤ºçš„å®£è¨€
emoji: ğŸ§‘â€ğŸ«
type: tech
topics: [cpp, cpp23]
published: false
---

:::message
ã“ã®è¨˜äº‹ã¯ [C++ Advent Calendar 2022](https://qiita.com/advent-calendar/2022/cxx) ã® 1 æ—¥ç›®ã®è¨˜äº‹ã§ã™ã€‚
:::

- **æ¦‚è¦**: æœ¬è¨˜äº‹ã§ã¯ C++23 ã«å‘ã‘ã¦æ¡æŠã•ã‚ŒãŸä»¥ä¸‹ã®è«–æ–‡ã®æ©Ÿèƒ½ã‚’ç´¹ä»‹ã—ã¦ã„ã¾ã™
  - [P0847R7 Deducing `this`](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2021/p0847r7.html)
  - [P2445R1 `std::forward_like`](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/p2445r1.pdf)
  - [P0798R3 Monadic operations for `std::optional`](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2019/p0798r3.html)

## ã¯ã˜ã‚ã«

2022 å¹´ã‚‚å¹´ã®ç€¬ã‚’è¿ãˆã€C++23 ã®ç™ºè¡ŒãŒã‚ã¨ 1 å¹´ã«è¿«ã£ã¦ãã¾ã—ãŸã€‚2022 å¹´ 11 æœˆã® Kona ä¼šè­°ã¯ç„¡äº‹çµ‚äº†ã—ã€é †èª¿ã«é€²ã‚ã° 2023 å¹´ 2 æœˆã® Issaquah ä¼šè­°ã§ç­–å®šãŒå®Œäº†ã™ã‚‹äºˆå®šã§ã™[^kona]ã€‚ãã‚ãã‚ C++23 ã®æ–°æ©Ÿèƒ½ãŒæ°—ã«ãªã£ã¦ããŸäººã‚‚å¤šã„ã®ã§ã¯ãªã„ã§ã—ã‚‡ã†ã‹ã€‚

[^kona]: [Trip report: Autumn ISO C++ standards meeting (Kona) - Sutterâ€™s Mill](https://herbsutter.com/2022/11/12/trip-report-autumn-iso-c-standards-meeting-kona/)

å€‹äººçš„ã« C++23 æœ€å¤§ã®æ©Ÿèƒ½ã¯ã€[P0847 Deducing `this`](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2021/p0847r7.html) ã«ã¦ææ¡ˆã•ã‚ŒãŸ **æ˜ç¤ºçš„ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆãƒ‘ãƒ©ãƒ¡ã‚¿ã®å°å…¥** ã ã¨æ„Ÿã˜ã¦ã„ã¾ã™[^my-wish]ã€‚ãã“ã§æœ¬è¨˜äº‹ã§ã¯ [P0847 Deducing `this`](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2021/p0847r7.html) ã¨ã€ã“ã‚Œã«éš£æ¥ã™ã‚‹ 2 ã¤ã®è«–æ–‡ã§å°å…¥ã•ã‚ŒãŸæ©Ÿèƒ½ã‚’ç´¹ä»‹ã—ã¾ã™ã€‚

[^my-wish]: ä»Šå¾Œã™ã¹ã¦ã®ãƒ¡ãƒ³ãƒé–¢æ•°ã‚’æ˜ç¤ºçš„ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆãƒ‘ãƒ©ãƒ¡ã‚¿ã‚’ç”¨ã„ã¦å®£è¨€ã—ãŸã„ãã‚‰ã„

## æ˜ç¤ºçš„ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆãƒ‘ãƒ©ãƒ¡ã‚¿ã¨ã¯

ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆãƒ‘ãƒ©ãƒ¡ã‚¿ (_object parameter_) ã¨ã¯ã€ã‚¯ãƒ©ã‚¹ã®ãƒ¡ãƒ³ãƒé–¢æ•°å†…ã§ã€ã‚¯ãƒ©ã‚¹ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆè‡ªèº«ã‚’æŒ‡ã™ãƒ‘ãƒ©ãƒ¡ã‚¿ã®ã“ã¨ã§ã™ã€‚C++ã§ã¯ã€ã‚¯ãƒ©ã‚¹ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆè‡ªèº«ã®ãƒã‚¤ãƒ³ã‚¿ã‚’æŒ‡ã™ã‚­ãƒ¼ãƒ¯ãƒ¼ãƒ‰ã¨ã—ã¦ã€`this` ã‚’ä½¿ç”¨ã™ã‚‹ã“ã¨ãŒã§ãã¾ã™ã€‚ã“ã‚Œã¯ãƒ¡ãƒ³ãƒé–¢æ•°å†…ã§æš—é»™çš„ã«å®£è¨€ã•ã‚Œã‚‹ãŸã‚ã€æš—é»™çš„ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆãƒ‘ãƒ©ãƒ¡ã‚¿ (_implicit object parameter_) ã¨å‘¼ã°ã‚Œã¾ã™ã€‚

ä¸€æ–¹ã€æ˜ç¤ºçš„ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆãƒ‘ãƒ©ãƒ¡ã‚¿ (_explicit object parameter_) ã‚’å®£è¨€ã™ã‚‹ã“ã¨ã¯ã€å¾“æ¥ã® C++ã§ã¯ã§ãã¾ã›ã‚“ã§ã—ãŸã€‚ã“ã‚Œã‚’å®Ÿç¾ã—ãŸã®ãŒã€C++23 ã«å‘ã‘ã¦æ¡æŠã•ã‚ŒãŸè«–æ–‡ã€[P0847 Deducing `this`](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2021/p0847r7.html) ã§ã™ã€‚

```cpp
struct X {
  void f() const& {}

  void g1() const& {
    this->f();
//  ^~~~ æš—é»™çš„ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆãƒ‘ãƒ©ãƒ¡ã‚¿
  }

  void g2(this const X& self) {
    self.f();
//  ^~~~ æ˜ç¤ºçš„ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆãƒ‘ãƒ©ãƒ¡ã‚¿
  }
};
```

### ã©ã†ã‚„ã£ã¦æ˜ç¤ºçš„ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆãƒ‘ãƒ©ãƒ¡ã‚¿ã‚’å®£è¨€ã§ãã‚‹ã‹?

æ˜ç¤ºçš„ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆãƒ‘ãƒ©ãƒ¡ã‚¿ã‚’å°å…¥ã™ã‚‹ãŸã‚ã«ã€ãƒ¡ãƒ³ãƒé–¢æ•°ã‚’å®£è¨€ã™ã‚‹æ–°ãŸãªæ§‹æ–‡ãŒè¿½åŠ ã•ã‚Œã¾ã—ãŸã€‚ãã®æ§‹æ–‡ã§ã¯ã€ãƒ¡ãƒ³ãƒé–¢æ•°ã®æœ€åˆã®ãƒ‘ãƒ©ãƒ¡ã‚¿ã®å…ˆé ­ã«ã€`this` ã‚­ãƒ¼ãƒ¯ãƒ¼ãƒ‰ã‚’ä»˜ã‘ã‚‹ã“ã¨ãŒã§ãã¾ã™ã€‚

```cpp
struct X {
  // const X&ã€€å‹ã®ã‚¯ãƒ©ã‚¹ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’å—ã‘å–ã‚‹
  void f1(this const X& self) {}
  // X&&ã€€å‹ã®ã‚¯ãƒ©ã‚¹ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’å—ã‘å–ã‚‹
  void f1(this X&& self);

  // ã‚¯ãƒ©ã‚¹ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®å‹ã‚’ãƒ†ãƒ³ãƒ—ãƒ¬ãƒ¼ãƒˆãƒ‘ãƒ©ãƒ¡ã‚¿ã«ã™ã‚‹ã“ã¨ã‚‚ã§ãã‚‹
  template <class Self>
  void f2(this const Self& self);

  // ã‚¯ãƒ©ã‚¹ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’ forwarding reference ã§å—ã‘å–ã‚‹ã“ã¨ã‚‚ã§ãã‚‹
  template <class Self>
  void f3(this Self&& self);

  // ãƒ†ãƒ³ãƒ—ãƒ¬ãƒ¼ãƒˆãƒ‘ãƒ©ãƒ¡ã‚¿ã‚’ auto ã«ã™ã‚‹ã“ã¨ã‚‚ã§ãã‚‹
  void f4(this auto&& self);
};

void foo(X& x) {
  // å¾“æ¥ã®éé™çš„ãƒ¡ãƒ³ãƒé–¢æ•°ã¨åŒã˜æ§‹æ–‡ã§å‘¼ã³å‡ºã™ã“ã¨ãŒã§ãã‚‹ã€‚f2, f3, f4 ã‚‚åŒæ§˜
  x.f1();
}
```

ã“ã®æ§‹æ–‡ã¯ãƒ©ãƒ ãƒ€å¼ã§ã‚‚ä½¿ç”¨ã™ã‚‹ã“ã¨ãŒã§ãã¾ã™ã€‚

```cpp
void f() {
  int captured = 0;
  // ãƒ©ãƒ ãƒ€å¼ã§ã‚‚æ˜ç¤ºçš„ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆãƒ‘ãƒ©ãƒ¡ã‚¿ã‚’å®£è¨€ã§ãã‚‹
  auto lambda = [captured](this auto&& self) -> decltype(auto) {
    return std::forward_like<decltype(self)>(captured);
  };
  // å¾“æ¥ã¨åŒã˜æ§‹æ–‡ã§å‘¼ã³å‡ºã™ã“ã¨ãŒã§ãã‚‹
  lambda();
}
```

ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆãƒ‘ãƒ©ãƒ¡ã‚¿ã®ãƒ‘ãƒ©ãƒ¡ã‚¿å (ä¸Šè¨˜ã®ä¾‹ã® `self`) ã¯ã€`self` ä»¥å¤–ã§ã‚‚æ§‹ã„ã¾ã›ã‚“ã€‚ã—ã‹ã—ã€ä»–è¨€èªã®æ…£ä¾‹ã«å‰‡ã£ã¦ `self` ã¨ã™ã‚‹ã®ãŒä¸€èˆ¬çš„ãªã‚ˆã†ã§ã™ã€‚

### æ³¨æ„ç‚¹

å‰é …ã§ã€ãƒ¡ãƒ³ãƒé–¢æ•°ã‚’å®£è¨€ã™ã‚‹æ–°ãŸãªæ§‹æ–‡ãŒè¿½åŠ ã•ã‚ŒãŸã“ã¨ã‚’èª¬æ˜ã—ã¾ã—ãŸã€‚ã“ã‚Œã¯å¾“æ¥ã®éé™çš„ãƒ¡ãƒ³ãƒé–¢æ•°ã®å®£è¨€ã¨ã€ã„ãã¤ã‹ç•°ãªã‚‹ç‚¹ãŒã‚ã‚Šã¾ã™ã€‚

- **`static`ãƒ»`virtual` ã‚’æŒ‡å®šã™ã‚‹ã“ã¨ã¯ã§ããšã€cvãƒ»å‚ç…§ä¿®é£¾ã™ã‚‹ã“ã¨ã‚‚ã§ããªã„**

  ```cpp
  struct B {
    static  void f1(this B const&);  // error
    virtual void f2(this B const&);  // error
    virtual void f3() const&;        // OK
    void f4(this B) const&;          // error
  };

  struct D : B {
    void f3() const& override;       // OK
    void f3(this D const&) override; // error
  };
  ```

- ã‚ªãƒ¼ãƒãƒ¼ãƒ­ãƒ¼ãƒ‰ã§æš—é»™çš„ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆãƒ‘ãƒ©ãƒ¡ã‚¿ã¨æ˜ç¤ºçš„ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆãƒ‘ãƒ©ãƒ¡ã‚¿ã‚’æ··åœ¨ã•ã›ã‚‹ã“ã¨ã¯è¨±å¯ã•ã‚Œã¦ã„ã‚‹ã€‚ã—ã‹ã—ã€**ã‚ªãƒ¼ãƒãƒ¼ãƒ­ãƒ¼ãƒ‰è§£æ±ºãŒä¸å¯èƒ½ãªæ··åœ¨ã¯è¨±å¯ã•ã‚Œã¦ã„ãªã„**

  ```cpp
  struct X {
    void f1(this X&);
    void f1() &&;           // OK: another overload
    void f2(this const X&);
    void f2() const&;       // error: redeclaration
    void f3();
    void f3(this X&);       // error: redeclaration
  };
  ```

- æ˜ç¤ºçš„ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆãƒ‘ãƒ©ãƒ¡ã‚¿ã‚’å®£è¨€ã—ãŸå ´åˆã€**æš—é»™çš„ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆãƒ‘ãƒ©ãƒ¡ã‚¿ã‚’ä½¿ç”¨ã™ã‚‹ã“ã¨ã¯ã§ããªã„**ã€‚ã™ãªã‚ã¡ã€**`this` ã‚„éä¿®é£¾ãƒ¡ãƒ³ãƒã‚¢ã‚¯ã‚»ã‚¹ã¯ä½¿ç”¨ã§ããªã„**

  ```cpp
  struct X {
    int i = 0;

    int f1(this auto&&) { return this->i; }     // error
    int f2(this auto&&) { return i; }           // error
    int f3(this auto&& self) { return self.i; } // OK
  };
  ```

- ã‚¯ãƒ©ã‚¹ã‚’ç¶™æ‰¿ã—ãŸå ´åˆã€**åŸºåº•ã‚¯ãƒ©ã‚¹ã§ç¾ã‚Œã‚‹æ˜ç¤ºçš„ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆãƒ‘ãƒ©ãƒ¡ã‚¿ã®ãƒ†ãƒ³ãƒ—ãƒ¬ãƒ¼ãƒˆå‹ã¯ã€æ´¾ç”Ÿã‚¯ãƒ©ã‚¹ã®å‹ã§æ¨å®šã•ã‚Œã‚‹**ã€‚ãã®çµæœã€**æ´¾ç”Ÿã‚¯ãƒ©ã‚¹ã®ãƒ¡ãƒ³ãƒãŒåŸºåº•ã‚¯ãƒ©ã‚¹ã®ãƒ¡ãƒ³ãƒã‚’éš è”½ã™ã‚‹ç¾è±¡ãŒç”Ÿã˜ã‚‹**

  ```cpp
  struct B {
    int i = 0;

    int f1(this const B& self) { return self.i; }
    int f2(this const auto& self) { return self.i; }
  };

  struct D : B {
    int i = 42; // B::i ã‚’éš è”½ã™ã‚‹
  };

  void foo(B& b, D& d) {
    assert(b.f1() == 0);  // 0 ã‚’è¿”ã™
    assert(b.f2() == 0);  // 0 ã‚’è¿”ã™
    assert(d.f1() == 0);  // 0 ã‚’è¿”ã™
    assert(d.f2() == 42); // self ã¯ D ã®å‚ç…§ã§æ¨å®šã•ã‚Œã‚‹ãŸã‚ã€42 ã‚’è¿”ã™
  }
  ```

  ã“ã®ä»•æ§˜ã¯æ­¦å™¨ã«ã‚‚ãªã‚Šã¾ã™ãŒã€æ„å›³ã›ã¬å‹•ä½œã‚’å¼•ãèµ·ã“ã™å‡¶å™¨ã«ã‚‚ãªã‚Šå¾—ã¾ã™ã€‚

<!-- TODO: ãƒ¡ãƒ³ãƒé–¢æ•°ãƒã‚¤ãƒ³ã‚¿ã®å‹ã«ã¤ã„ã¦ -->

### ãƒ¡ãƒªãƒƒãƒˆ

æ˜ç¤ºçš„ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆãƒ‘ãƒ©ãƒ¡ã‚¿ã‚’ forwarding reference ã§å—ã‘å–ã‚‹ã“ã¨ã§ã€ã‚¯ãƒ©ã‚¹ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã® cvãƒ»å‚ç…§ä¿®é£¾ã‚’æ¨å®šã™ã‚‹ã“ã¨ãŒã§ãã¾ã™ã€‚ã“ã‚Œã«ã‚ˆã£ã¦ã€ãƒ¡ãƒ³ãƒé–¢æ•°å†…ã§ã‚¯ãƒ©ã‚¹ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’å®Œå…¨è»¢é€ã™ã‚‹ã“ã¨ãŒã§ãã‚‹ã‚ˆã†ã«ãªã‚Šã¾ã™ã€‚

```cpp
struct negative {
  constexpr bool operator()(int x) const { return x < 0; }

  template <class Self>
  constexpr auto negate(this Self&& self) {
    return std::not_fn(std::forward<Self>(self));
    //                 ^~~~~~~~~~~~~~~~~~~~~~~~ self ã‚’å®Œå…¨è»¢é€ã§ãã‚‹
  }
};

inline constexpr auto non_negative = negative{}.negate();
```

ã“ã‚Œã¯ã€æ¬¡ã§è¿°ã¹ã‚‹ `std::forward_like` ã¨çµ„ã¿åˆã‚ã›ã‚‹ã“ã¨ã§ã€**ã‚¯ãƒ©ã‚¹ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã® constãƒ»å‚ç…§ä¿®é£¾ã§ãƒ¡ãƒ³ãƒå¤‰æ•°ã‚’è»¢é€ã§ãã‚‹** ã“ã¨ã‚’æ„å‘³ã—ã¦ã„ã¾ã™ã€‚

## `std::forward_like` ã¨ã¯

`std::forward_like` ã¯ã€ç¬¬ä¸€ãƒ†ãƒ³ãƒ—ãƒ¬ãƒ¼ãƒˆå¼•æ•°ã® constãƒ»å‚ç…§ä¿®é£¾ã‚’ç”¨ã„ã¦ã€å¼•æ•°ã‚’è»¢é€ã™ã‚‹é–¢æ•°ã§ã™ã€‚åŸºæœ¬çš„ã«ã¯ `std::forward_like<T>(x)` ã®ã‚ˆã†ã«ã€1 ã¤ã®ãƒ†ãƒ³ãƒ—ãƒ¬ãƒ¼ãƒˆå¼•æ•°ã¨ 1 ã¤ã®å¼•æ•°ã‚’æ¸¡ã—ã¦ä½¿ç”¨ã—ã¾ã™ã€‚ã“ã‚Œã«ã‚ˆã£ã¦ `T` ã® const æ€§ã‚’ãƒãƒ¼ã‚¸ã— `T` ã®å€¤ã‚«ãƒ†ã‚´ãƒªã‚’ã‚³ãƒ”ãƒ¼ã—ãŸå‹ã§ã€`x` ã‚’è»¢é€ã™ã‚‹ã“ã¨ãŒã§ãã¾ã™ã€‚

```cpp
void f(int& a, int& b, const int& c, const int& d) {
  {
    int&  x = std::forward_like<char&>(a);
    int&& y = std::forward_like<char>(a);
    const int&  z = std::forward_like<const char&>(b);
    const int&& w = std::forward_like<const char>(b);
  }
  {
    const int&  x = std::forward_like<char&>(c);
    const int&& y = std::forward_like<char>(c);
    const int&  z = std::forward_like<const char&>(d);
    const int&& w = std::forward_like<const char>(d);
  }
}
```

`std::forward_like` ã‚’ç”¨ã„ã‚‹ã“ã¨ã§ã€ã‚¯ãƒ©ã‚¹ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã® constãƒ»å‚ç…§ä¿®é£¾ã«åˆã‚ã›ã¦ãƒ¡ãƒ³ãƒå¤‰æ•°ã‚’æ­£ã—ãè»¢é€ã™ã‚‹ã“ã¨ãŒã§ãã‚‹ã‚ˆã†ã«ãªã‚Šã¾ã™ã€‚

```cpp
struct X {
  int i = 0;

  template <class Self>
  decltype(auto) f(this Self&& self) {
    return std::forward_like<Self>(self.i);
  }
};

void foo(X& x) {
  int& a = x.f();             // int& ã‚’è¿”ã™
  int&& b = std::move(x).f(); // int&& ã‚’è¿”ã™
}
```
