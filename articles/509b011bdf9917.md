---
title: "`__perfect_forward` ã®ä»•çµ„ã¿ã¨ä½¿ã„æ–¹"
emoji: "ğŸ“"
type: "tech"
topics: ["cpp", "cpp20"]
published: true
---

<!-- `__perfect_forward` ã®ä»•çµ„ã¿ã¨ä½¿ã„æ–¹ -->
:::message
ã“ã®è¨˜äº‹ã¯ [C++ Advent Calendar 2021](https://qiita.com/advent-calendar/2021/cxx) ã®2æ—¥ç›®ã®è¨˜äº‹ã§ã™ã€‚
:::

# æ¦‚è¦
- libc++ ã® `__perfect_forward` ã®ä»•çµ„ã¿ã¨ä½¿ã„æ–¹ã«ã¤ã„ã¦èª¿ã¹ãŸã€‚
- `__perfect_forward` ã¯ perfect forwarding call wrapper ã‚’å®Ÿç¾ã™ã‚‹åŸºåº•ã‚¯ãƒ©ã‚¹ã§ã‚ã‚‹ã€‚
- perfect forwarding call wrapper ã¯è‡ªèº«ã® constãƒ»reference ä¿®é£¾ã‚’å®Œå…¨è»¢é€ã™ã‚‹ call wrapper ã§ã‚ã‚‹ã€‚

# å‹•æ©Ÿ
æ¨™æº–ãƒ©ã‚¤ãƒ–ãƒ©ãƒªã®é–¢æ•°ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’è¿”ã™é–¢æ•°ã‚’ã‚ˆãä½¿ã„ã¾ã™ã‹? ä¾‹ãˆã° `std::not_fn`ã€ `std::bind_front` ãªã©ã§ã™[^1]ã€‚C++23 ã§ã¯ `std::bind_back` ãŒãƒ¯ãƒ¼ã‚­ãƒ³ã‚°ãƒ‰ãƒ©ãƒ•ãƒˆå…¥ã‚Šã‚’ç›®æŒ‡ã—ã¦ã„ã¾ã™[^2]ã€‚ã“ã®ã‚ˆã†ãªé–¢æ•°ã®è¿”ã™é–¢æ•°ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¯ã©ã®ã‚ˆã†ã«å®Ÿè£…ã•ã‚Œã¦ã„ã‚‹ã®ã§ã—ã‚‡ã†ã€‚

[^1]: https://en.cppreference.com/w/cpp/utility/functional "Function objects - cppreference.com"
[^2]: https://wg21.link/p2387 "P2387"

ä¾‹ã¨ã—ã¦ llvm ã® [libc++](https://github.com/llvm/llvm-project/tree/main/libcxx/include) ã‚’é™¤ã„ã¦ã¿ãŸã¨ã“ã‚ã€ `__perfect_forward` ã¨ã„ã†ã‚¯ãƒ©ã‚¹ã«é­é‡ã—ã¾ã—ãŸã€‚ã“ã®ã‚¯ãƒ©ã‚¹ãŒã‚ˆãå‡ºæ¥ã¦ã„ã‚‹ã¨æ€ã„ã€ä½¿ã„æ–¹ã‚’èª¿ã¹ãŸã®ãŒæœ¬è¨˜äº‹ã§ã™ã€‚

# `__perfect_forward` ã®ç›®æŒ‡ã™ã¨ã“ã‚
é–¢æ•°ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã€ä¾‹ãˆã° `std::not_fn` ã®è¿”ã™é–¢æ•°ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã§ã‚ã‚‹ `not_fn_t` ã‚’æ­£ã—ãå®šç¾©ã™ã‚‹ã«ã¯ã€ä»¥ä¸‹ã®ã‚ˆã†ã«æ›¸ãå¿…è¦ãŒã‚ã‚Šã¾ã™ã€‚

```cpp
template<class F>
struct not_fn_t {
    F f;
    template<class... Args>
    constexpr auto operator()(Args&&... args) &
        noexcept(noexcept(!std::invoke(f, std::forward<Args>(args)...)))
        -> decltype(!std::invoke(f, std::forward<Args>(args)...))
    {
        return !std::invoke(f, std::forward<Args>(args)...);
    }

    template<class... Args>
    constexpr auto operator()(Args&&... args) const&
        noexcept(noexcept(!std::invoke(f, std::forward<Args>(args)...)))
        -> decltype(!std::invoke(f, std::forward<Args>(args)...))
    {
        return !std::invoke(f, std::forward<Args>(args)...);
    }

    template<class... Args>
    constexpr auto operator()(Args&&... args) &&
        noexcept(noexcept(!std::invoke(std::move(f), std::forward<Args>(args)...)))
        -> decltype(!std::invoke(std::move(f), std::forward<Args>(args)...))
    {
        return !std::invoke(std::move(f), std::forward<Args>(args)...);
    }

    template<class... Args>
    constexpr auto operator()(Args&&... args) const&&
        noexcept(noexcept(!std::invoke(std::move(f), std::forward<Args>(args)...)))
        -> decltype(!std::invoke(std::move(f), std::forward<Args>(args)...))
    {
        return !std::invoke(std::move(f), std::forward<Args>(args)...);
    }
};
```

*Reference: [cppreference.com](https://en.cppreference.com/w/cpp/utility/functional/not_fn)*

**ä¼¼ãŸã‚³ãƒ¼ãƒ‰ã‚’12å›ã‚‚ã‚¿ã‚¤ãƒ—ã—ãªã‘ã‚Œã°ãªã‚Šã¾ã›ã‚“**ã€‚ã•ã‚‰ã«ã€**`*this` ãŒ lvalue ã‹ rvalue ã‹ã«ã‚ˆã£ã¦ã‚ªãƒ¼ãƒãƒ¼ãƒ­ãƒ¼ãƒ‰ãŒå°‘ã—ç•°ãªã‚Šã¾ã™**ã€‚

ã—ã‹ã—ã€ `__perfect_forward` ã‚’ç”¨ã„ã‚‹ã¨ã€ä»¥ä¸‹ã®ã‚ˆã†ã«æ›¸ã‘ã¾ã™ã€‚

```cpp
struct not_fn_op {
    template <class... Args>
    constexpr auto operator()(Args&&... args) const
        noexcept(noexcept(!std::invoke(std::forward<Args>(args)...)))
        -> decltype(      !std::invoke(std::forward<Args>(args)...))
        { return          !std::invoke(std::forward<Args>(args)...); }
};

template <class F>
struct not_fn_t : __perfect_forward<not_fn_op, F> {
    using __perfect_forward<not_fn_op, F>::__perfect_forward;
};
```

*Reference: [llvm](https://github.com/llvm/llvm-project/blob/4e0ea2cf2e7c5f04c526f5476eff70280f3c0871/libcxx/include/__functional/not_fn.h) (partially modified)*

**ç¹°ã‚Šè¿”ã—ãŒ3å›ã«æ¸›ã‚Šã¾ã—ãŸ**[^3]ğŸ¤— ã“ã®ã‚ˆã†ã«é–¢æ•°ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã® `operator()` ã®ã‚ªãƒ¼ãƒãƒ¼ãƒ­ãƒ¼ãƒ‰ã‚’ä¸€å…ƒåŒ–ã—ã¤ã¤ã€å¼•æ•°ã®å®Œå…¨è»¢é€ã‚’æ­£ã—ãè¡Œã†ã“ã¨ãŒ `__perfect_forward` ã®ç›®æŒ‡ã™ã¨ã“ã‚ã§ã™ã€‚

[^3]: ã“ã®3å›ã®ç¹°ã‚Šè¿”ã—ã‚’1å›ã«æ¸›ã‚‰ã™ãŸã‚ã®ææ¡ˆ [P0573](https://wg21.link/p0573) ãŒã‚ã‚Šã¾ã—ãŸãŒ reject ã•ã‚Œã¾ã—ãŸã€‚reject ã•ã‚ŒãŸçµŒç·¯ã¯ [Why were abbrev. lambdas rejected?](https://brevzin.github.io/c++/2020/01/15/abbrev-lambdas/) ã«ã‚ã‚Šã¾ã™ã€‚ã•ã‚‰ã«ã“ã®ææ¡ˆã‚’ brush up ã—ãŸææ¡ˆ [P2425](https://wg21.link/p2425) ãŒãªã•ã‚Œã¦ã„ã¾ã™ã€‚ã“ã®ææ¡ˆã®æ—¥æœ¬èªã®è§£èª¬è¨˜äº‹ãŒ [ï¼»C++ï¼½WG21æœˆæ¬¡ææ¡ˆæ–‡æ›¸ã‚’çœºã‚ã‚‹ï¼ˆ2021å¹´08æœˆï¼‰ - åœ°é¢ã‚’è¦‹ä¸‹ã‚ã™å°‘å¹´ã®è¶³è¹´ã«ã•ã‚Œã‚‹ç§](https://onihusube.hatenablog.com/entry/2021/09/03/230045#P2425R0-Expression-Function-Body) ã«ã‚ã‚Šã¾ã™ã€‚

# `__perfect_forward` ã®å®Ÿè£…
`__perfect_forward` ã¯ä»¥ä¸‹ã®ã‚ˆã†ã«å®Ÿè£…ã•ã‚Œã¦ã„ã¾ã™ã€‚

```cpp
template <class Op, class Indices, class ...Bound>
struct __perfect_forward_impl;

template <class Op, std::size_t ...Idx, class ...Bound>
struct __perfect_forward_impl<Op, std::index_sequence<Idx...>, Bound...> {
private:
    std::tuple<Bound...> bound_;

public:
    template <class ...BoundArgs, class = std::enable_if_t<
        std::is_constructible_v<std::tuple<Bound...>, BoundArgs&&...>
    >>
    explicit constexpr __perfect_forward_impl(BoundArgs&& ...bound)
        : bound_(std::forward<BoundArgs>(bound)...)
    { }

    __perfect_forward_impl(__perfect_forward_impl const&) = default;
    __perfect_forward_impl(__perfect_forward_impl&&) = default;

    __perfect_forward_impl& operator=(__perfect_forward_impl const&) = default;
    __perfect_forward_impl& operator=(__perfect_forward_impl&&) = default;

    template <class ...Args, class = std::enable_if_t<std::is_invocable_v<Op, Bound&..., Args...>>>
    constexpr auto operator()(Args&&... args) &
        noexcept(noexcept(Op()(std::get<Idx>(bound_)..., std::forward<Args>(args)...)))
        -> decltype(      Op()(std::get<Idx>(bound_)..., std::forward<Args>(args)...))
        { return          Op()(std::get<Idx>(bound_)..., std::forward<Args>(args)...); }

    template <class ...Args, class = std::enable_if_t<!std::is_invocable_v<Op, Bound&..., Args...>>>
    auto operator()(Args&&...) & = delete;

    template <class ...Args, class = std::enable_if_t<std::is_invocable_v<Op, Bound const&..., Args...>>>
    constexpr auto operator()(Args&&... args) const&
        noexcept(noexcept(Op()(std::get<Idx>(bound_)..., std::forward<Args>(args)...)))
        -> decltype(      Op()(std::get<Idx>(bound_)..., std::forward<Args>(args)...))
        { return          Op()(std::get<Idx>(bound_)..., std::forward<Args>(args)...); }

    template <class ...Args, class = std::enable_if_t<!std::is_invocable_v<Op, Bound const&..., Args...>>>
    auto operator()(Args&&...) const& = delete;

    template <class ...Args, class = std::enable_if_t<std::is_invocable_v<Op, Bound..., Args...>>>
    constexpr auto operator()(Args&&... args) &&
        noexcept(noexcept(Op()(std::get<Idx>(std::move(bound_))..., std::forward<Args>(args)...)))
        -> decltype(      Op()(std::get<Idx>(std::move(bound_))..., std::forward<Args>(args)...))
        { return          Op()(std::get<Idx>(std::move(bound_))..., std::forward<Args>(args)...); }

    template <class ...Args, class = std::enable_if_t<!std::is_invocable_v<Op, Bound..., Args...>>>
    auto operator()(Args&&...) && = delete;

    template <class ...Args, class = std::enable_if_t<std::is_invocable_v<Op, Bound const..., Args...>>>
    constexpr auto operator()(Args&&... args) const&&
        noexcept(noexcept(Op()(std::get<Idx>(std::move(bound_))..., std::forward<Args>(args)...)))
        -> decltype(      Op()(std::get<Idx>(std::move(bound_))..., std::forward<Args>(args)...))
        { return          Op()(std::get<Idx>(std::move(bound_))..., std::forward<Args>(args)...); }

    template <class ...Args, class = std::enable_if_t<!std::is_invocable_v<Op, Bound const..., Args...>>>
    auto operator()(Args&&...) const&& = delete;
};

// __perfect_forward implements a perfect-forwarding call wrapper as explained in [func.require].
template <class Op, class ...Args>
using __perfect_forward = __perfect_forward_impl<Op, std::index_sequence_for<Args...>, Args...>;
```

*Reference: [llvm](https://github.com/llvm/llvm-project/blob/4e0ea2cf2e7c5f04c526f5476eff70280f3c0871/libcxx/include/__functional/perfect_forward.h) (partially modified)*

## ãƒ†ãƒ³ãƒ—ãƒ¬ãƒ¼ãƒˆå¼•æ•°ãƒ»ãƒ¡ãƒ³ãƒé–¢æ•°
```cpp
template <class Op, class Indices, class ...Bound>
struct __perfect_forward_impl;

template <class Op, std::size_t ...Idx, class ...Bound>
struct __perfect_forward_impl<Op, std::index_sequence<Idx...>, Bound...> {
private:
    std::tuple<Bound...> bound_;
};

template <class Op, class ...Args>
using __perfect_forward = __perfect_forward_impl<Op, std::index_sequence_for<Args...>, Args...>;
```

`Op` ã¯ã‚ªãƒªã‚¸ãƒŠãƒ«ã®é–¢æ•°ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆå‹ ([function object type](https://timsong-cpp.github.io/cppwp/n4861/function.objects#def:function_object,type)) ã‚’è¡¨ã—ã¾ã™ã€‚ [`not_fn_t`](#`__perfect_forward`%20ã®ç›®æŒ‡ã™ã¨ã“ã‚) ã®ä¾‹ã§ã¯ `not_fn_op` ã«å¯¾å¿œã—ã¾ã™ã€‚ `std::index_sequence<Idx...>` ã¯ `operator()` ã«ãŠã„ã¦ `std::tuple<Bound...>` å‹ã§ã‚ã‚‹ `bound_` ã‚’å±•é–‹ã™ã‚‹ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ãƒªã‚¹ãƒˆã§ã™ã€‚ `Bound...` ã¯ä¸€æ™‚çš„ã«ä¿å­˜ã™ã‚‹å¤‰æ•°ã®å‹ã§ã‚ã‚Šã€ãã®å¤‰æ•°ã¯ `std::tuple<Bound...>` å‹ã§ã‚ã‚‹ `bound_` ã«æŸç¸›ã•ã‚Œã¾ã™ã€‚

**`Bound...` ã¯ä¸»ã« cvãƒ»reference ä¿®é£¾ã®ç„¡ã„å‹ã‚’æƒ³å®šã—ã¦ã„ã¾ã™**ã€‚ã“ã®ã“ã¨ã¯ [llvm ã®ä¾‹](#`__perfect_forward`%20ã®ç›®æŒ‡ã™ã¨ã“ã‚) ã«ãŠã‘ã‚‹ `std::not_fn` ãŠã„ã¦ã€ `not_fn_t` ã®åˆæœŸåŒ–ãŒä¸‹è¨˜ã®ã‚ˆã†ã« `not_fn_t<std::decay_t<F>>` ã¨è¡Œã‚ã‚Œã¦ã„ã‚‹ã“ã¨ã‹ã‚‰ã‚‚ã‚ã‹ã‚Šã¾ã™ã€‚

```cpp
template <class F, class = std::enable_if_t<
    std::is_constructible_v<std::decay_t<F>, F> &&
    std::is_move_constructible_v<std::decay_t<F>>
>>
constexpr auto not_fn(F&& f) {
    return not_fn_t<std::decay_t<F>>(std::forward<F>(f));
}
```

*Reference: [llvm](https://github.com/llvm/llvm-project/blob/4e0ea2cf2e7c5f04c526f5476eff70280f3c0871/libcxx/include/__functional/not_fn.h) (partially modified)*

`not_fn_t<F>` ã¨åˆæœŸåŒ–ã—ãŸå ´åˆã€ `not_fn` ã®å¼•æ•°ã« lvalue ã‚’æ¸¡ã™ã¨ `F` ã¯ lvalue-reference ã¨ãªã‚Šã¾ã™ã€‚ã“ã®ã¨ã `not_fn_t` ã® `operator()` ãŒå…ˆã»ã©æ¸¡ã—ãŸ lvalue ã®å¯¿å‘½ã‚ˆã‚Šå¾Œã«å‘¼ã°ã‚Œã‚‹ã¨ã€dangling reference ã‚’å¼•ãèµ·ã“ã—å±é™ºã§ã™ã€‚ã“ã‚ŒãŒ `Bound` ãŒä¸»ã« cvãƒ»reference ä¿®é£¾ã®ç„¡ã„å‹ã‚’æƒ³å®šã—ã¦ã„ã‚‹ç†ç”±ã¨ãªã‚Šã¾ã™ã€‚

```cpp
// Bad example
template <class F, class = std::enable_if_t<
    std::is_constructible_v<std::decay_t<F>, F> &&
    std::is_move_constructible_v<std::decay_t<F>>
>>
constexpr auto not_fn(F&& f) {
    return not_fn_t<F>(std::forward<F>(f));
    //     ^~~~~~~~~~~ not `not_fn_t<std::decay_t<F>>`
}

int main() {
  using true_fn_t = decltype([](auto&&) { return true; });
  true_fn_t fn{};
  not_fn(fn);          // F = true_fn_t& â†’ dangling reference may arise.
  not_fn(true_fn_t{}); // F = true_fn_t
}
```

## ã‚³ãƒ³ã‚¹ãƒˆãƒ©ã‚¯ã‚¿
```cpp
template <class ...BoundArgs, class = std::enable_if_t<
    std::is_constructible_v<std::tuple<Bound...>, BoundArgs&&...>
>>
explicit constexpr __perfect_forward_impl(BoundArgs&& ...bound)
    : bound_(std::forward<BoundArgs>(bound)...)
{ }
```

ã‚³ãƒ”ãƒ¼ã‚³ãƒ³ã‚¹ãƒˆãƒ©ã‚¯ã‚¿ã€ãƒ ãƒ¼ãƒ–ã‚³ãƒ³ã‚¹ãƒˆãƒ©ã‚¯ã‚¿ã®ä»–ã« `bound_` ã‚’åˆæœŸåŒ–ã™ã‚‹ã‚³ãƒ³ã‚¹ãƒˆãƒ©ã‚¯ã‚¿ã‚’ã‚‚ã¡ã¾ã™ã€‚ [å‰é …](#temp-params-member) ã®é€šã‚Š `Bound...` ã¯ä¸»ã« decay ã•ã‚ŒãŸå‹ã§ã‚ã‚‹ãŸã‚ã€ å‹ `Bound...` ã¯ã“ã®ã‚³ãƒ³ã‚¹ãƒˆãƒ©ã‚¯ã‚¿ã®ãƒ†ãƒ³ãƒ—ãƒ¬ãƒ¼ãƒˆå¼•æ•° `BoundArgs` ã® cvãƒ»reference ä¿®é£¾ã¨ã„ã†æƒ…å ±ã‚’ä¿æŒã—ã¾ã›ã‚“ã€‚ã™ãªã‚ã¡ã“ã®ã‚³ãƒ³ã‚¹ãƒˆãƒ©ã‚¯ã‚¿ã§ `bound_` ã®å„è¦ç´ ã¯ã‚³ãƒ”ãƒ¼åˆæœŸåŒ–ã‚‚ã—ãã¯ãƒ ãƒ¼ãƒ–åˆæœŸåŒ–ã•ã‚Œã¾ã™ã€‚

## `operator()`
`operator()` ã¯ä¸€æ™‚ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆ `Op()` ã® `operator()` ã®å¼•æ•°ã«ã€ä¸€æ™‚çš„ã«ä¿å­˜ã—ãŸå¤‰æ•° `bound_` ã¨ä»Šå›å—ã‘å–ã£ãŸå¤‰æ•° `args...` ã‚’è»¢é€ã—ã¾ã™ã€‚å‹•ä½œã¯ã“ã‚Œã ã‘ã§ã™ãŒã€ `*this` ã® constãƒ»reference ä¿®é£¾ãŒ `&` ã€`const&` ã€`&&` ã€`const&&` ã®4é€šã‚Šã«åˆ†å²ã—ã¦ã‚ªãƒ¼ãƒãƒ¼ãƒ­ãƒ¼ãƒ‰ã•ã‚Œã¦ã„ã¾ã™ã€‚const ä¿®é£¾ã®æœ‰ç„¡ã«é–¢ã™ã‚‹ã‚ªãƒ¼ãƒãƒ¼ãƒ­ãƒ¼ãƒ‰ã®å·®ç•°ã¯ç›´æ„Ÿçš„ã«ç†è§£ã§ãã¾ã™ãŒã€lvalue-reference ã‹ rvalue-reference ã‹ã«é–¢ã™ã‚‹ã‚ªãƒ¼ãƒãƒ¼ãƒ­ãƒ¼ãƒ‰ã®å·®ç•°ã¯ç†è§£ã—é›£ã„ã®ã§è©³ã—ãå–ã‚Šä¸Šã’ã¾ã™ã€‚

```cpp
template <class ...Args, class = std::enable_if_t<std::is_invocable_v<Op, Bound&..., Args...>>>
constexpr auto operator()(Args&&... args) &
    noexcept(noexcept(Op()(std::get<Idx>(bound_)..., std::forward<Args>(args)...)))
    -> decltype(      Op()(std::get<Idx>(bound_)..., std::forward<Args>(args)...))
    { return          Op()(std::get<Idx>(bound_)..., std::forward<Args>(args)...); }

template <class ...Args, class = std::enable_if_t<std::is_invocable_v<Op, Bound..., Args...>>>
//                                                                        ^~~~~~~~ difference (1)
constexpr auto operator()(Args&&... args) &&
    noexcept(noexcept(Op()(std::get<Idx>(std::move(bound_))..., std::forward<Args>(args)...)))
    -> decltype(      Op()(std::get<Idx>(std::move(bound_))..., std::forward<Args>(args)...))
    { return          Op()(std::get<Idx>(std::move(bound_))..., std::forward<Args>(args)...); }
    //                                   ^~~~~~~~~~~~~~~~~ difference (2)
```

`operator()` ã®æŒ™å‹•ã¯ C++20 è¦æ ¼æ›¸ 20.14.3é … [func.require] ã® perfect forwarding call wrapper ã«è¨˜è¼‰ã•ã‚Œã¦ã„ã¾ã™ã€‚

> A *perfect forwarding call wrapper* is an argument forwarding *[call wrapper](https://timsong-cpp.github.io/cppwp/n4861/func.def#def:call_wrapper)* that forwards its state entities to the underlying call expression. This forwarding step delivers a state entity of type `T` as *cv* `T&` when the call is performed on an lvalue of the call wrapper type and as *cv* `T&&` otherwise, where *cv* represents the *cv*-qualifiers of the call wrapper and where *cv* shall be neither `volatile` nor `const volatile`.

*Reference: [ISO C++ standards committee](https://timsong-cpp.github.io/cppwp/n4861/func.require#def:perfect_forwarding_call_wrapper)*

perfect forwarding call wrapper ã¯**è‡ªèº«ãŒ `(const)&` ã®ã¨ãã¯å¼•æ•°å‹ `T` ã‚’ `(const) T` ã¨ã—ã¦è»¢é€ã—ã€è‡ªèº«ãŒ `(const)&&` ã®ã¨ãã¯å¼•æ•°å‹ã‚’ `(const) T&&` ã¨ã—ã¦è»¢é€ã—ã¾ã™**ã€‚ã“ã“ã§ *perfect forwarding* ã¨è¡¨ç¾ã—ã¦ã„ã‚‹ã®ã¯ call wrapper ã® constãƒ»reference ä¿®é£¾ã‚’å®Œå…¨è»¢é€ã™ã‚‹ã“ã¨ã‚’æ„å‘³ã—ã¦ãŠã‚Šã€ `bound_` ã«æŸç¸›ã™ã‚‹å‰ã®ã‚‚ã¨ã®å¼•æ•°å‹(ä¾‹ãˆã° `BoundArgs...`)ã® constãƒ»reference ä¿®é£¾ã‚’å®Œå…¨è»¢é€ã™ã‚‹ã“ã¨ã‚’æ„å‘³ã—ã¦ã„ã¾ã›ã‚“ã€‚

`std::get` ã®å®£è¨€ã¯ C++20 è¦æ ¼æ›¸ 20.5.7é … [tuple.elem] ã«è¨˜è¼‰ã•ã‚Œã¦ã„ã¾ã™ã€‚

```cpp
template<size_t I, class... Types>
constexpr tuple_element_t<I, tuple<Types...>>&
get(tuple<Types...>& t) noexcept;

template<size_t I, class... Types>
constexpr tuple_element_t<I, tuple<Types...>>&&
get(tuple<Types...>&& t) noexcept;

template<size_t I, class... Types>
constexpr const tuple_element_t<I, tuple<Types...>>&
get(const tuple<Types...>& t) noexcept;

template<size_t I, class... Types>
constexpr const tuple_element_t<I, tuple<Types...>>&&
get(const tuple<Types...>&& t) noexcept;
```

*Reference: [ISO C++ standards committee](https://timsong-cpp.github.io/cppwp/n4861/tuple.elem)*

`std::get` ã« lvalue ã§ã‚ã‚‹ `bound_` ã‚’æ¸¡ã›ã° `std::get<Idx>(bound_)...` ã®å‹ã¯ `Bound&...` ã¨ãªã‚Šã¾ã™ã€‚ä¸€æ–¹ `std::get` ã« rvalue ã§ã‚ã‚‹ `std::move(bound_)` ã‚’æ¸¡ã›ã° `std::get<Idx>(std::move(bound_))...` ã®å‹ã¯ `Bound&&...` ã¨ãªã‚Šã¾ã™ã€‚ã™ãªã‚ã¡ `std::move` ã®æœ‰ç„¡ã¨ `std::get` ã‚’çµ„ã¿åˆã‚ã›ã‚‹ã“ã¨ã§ [perfect forwarding call wrapper](https://timsong-cpp.github.io/cppwp/n4861/func.require#def:perfect_forwarding_call_wrapper) ã®å‹•ä½œãŒå®Ÿç¾ã•ã‚Œã¦ã„ã¾ã™ã€‚

```cpp
template <class ...Args, class = std::enable_if_t<!std::is_invocable_v<Op, Bound&..., Args...>>>
auto operator()(Args&&...) & = delete;
// ... and other three overloads
```

`operator()` ã«å¿…è¦ãªåˆ¶ç´„ (ä¾‹ãˆã° `std::is_invocable_v<Op, Bound&..., Args...>`) ãŒæº€ãŸã•ã‚Œãªã„å ´åˆ `operator()` ã¯ delete æŒ‡å®šã•ã‚Œã¾ã™[^4]ã€‚

[^4]: ã“ã“ã§ã¯ [`std::enable_if`](https://en.cppreference.com/w/cpp/types/enable_if) ã‚’ç”¨ã„ã¦å‹åˆ¶ç´„ã‚’å®Ÿç¾ã—ã¦ã„ã¾ã™ã€‚C++20 ã‹ã‚‰ã¯ [requires ç¯€](https://cpprefjp.github.io/lang/cpp20/concepts.html#:~:text=requires%E7%AF%80) ã‚’ç”¨ã„ã¦ã‚ˆã‚Šç°¡æ½”ã«åˆ¶ç´„ã‚’è¨˜è¿°ã§ãã¾ã™ã€‚

# `__perfect_forward` ã®ä½¿ã„æ–¹
ä»¥ä¸Šã§ã‚‚ `std::not_fn` ã‚’ä¾‹ã«ä½¿ã„æ–¹ã‚’èª¬æ˜ã—ã¾ã—ãŸãŒã€ã“ã“ã§ã¯æ–°ãŸã« `operator+` ã®ç¬¬ä¸€å¼•æ•°ã«å¤‰æ•°ã‚’éƒ¨åˆ†é©ç”¨ã—ã¦å¾—ã‚‰ã‚Œã‚‹é–¢æ•° `partially_applied_plus` ã‚’å®Ÿè£…ã—ã¾ã™ã€‚

```cpp
int main() {
    constexpr auto fn = partially_applied_plus(42);
    std::cout << fn(1) << std::endl; // 43
}
```

## æ‰‹é †1: å…ƒã¨ãªã‚‹é–¢æ•°ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆå‹ã‚’å®Ÿè£…ã™ã‚‹
å¼•æ•°ã®è»¢é€å…ˆã¨ãªã‚‹é–¢æ•°ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆå‹ã§ã‚ã‚‹ã€ `partially_applied_plus_op` ã‚’å®Ÿè£…ã—ã¾ã™ã€‚ã“ã®é–¢æ•°ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆå‹ã¯çŠ¶æ…‹ã‚’ä¿æŒã—ãªã„ãŸã‚ã€ `operator()` ã¯ `*this` ãŒ `const` ã®å ´åˆã®ã¿ã‚ªãƒ¼ãƒãƒ¼ãƒ­ãƒ¼ãƒ‰ã™ã‚Œã°ååˆ†ã§ã™ã€‚ä¾‹å¤–æŒ‡å®šã¨å¾Œç½®æˆ»ã‚Šå€¤å‹ã‚‚æ­£ã—ãæ›¸ãã¾ã™ã€‚

```cpp
struct partially_applied_plus_op {
    template <class T, class U>
    constexpr auto operator()(T&& t, U&& u) const noexcept(
        noexcept(   std::forward<T>(t) + std::forward<U>(u)))
        -> decltype(std::forward<T>(t) + std::forward<U>(u)) {
        return      std::forward<T>(t) + std::forward<U>(u);
    }
};
```

èª¬æ˜ã®ãŸã‚å®Ÿè£…ã—ã¾ã—ãŸãŒã€ `partially_applied_plus_op` ã¯ `std::plus<>` ã‚’ä½¿ãˆã°ååˆ†ã§ã™ã€‚

```cpp
using partially_applied_plus_op = std::plus<>;
```

## æ‰‹é †2: perfect forwarding call wrapper å‹ã‚’å®Ÿè£…ã™ã‚‹
[perfect forwarding call wrapper](https://timsong-cpp.github.io/cppwp/n4861/func.require#def:perfect_forwarding_call_wrapper) ã«å¾“ã„å¼•æ•°ã‚’å®Œå…¨è»¢é€ã™ã‚‹é–¢æ•°ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆå‹ã‚’å®Ÿè£…ã—ã¾ã™ã€‚ `__perfect_forward<partially_applied_plus_op, T>` ã‚’ public ç¶™æ‰¿ã™ã‚‹ã“ã¨ã§ `operator=` ã¨ `operator()` ã‚’å®£è¨€ã—ã¾ã™ã€‚ã•ã‚‰ã«ç¶™æ‰¿ã‚³ãƒ³ã‚¹ãƒˆãƒ©ã‚¯ã‚¿ (`using __perfect_forward<partially_applied_plus_op, T>::__perfect_forward`) ã‚’ç”¨ã„ã¦åŸºåº•ã‚¯ãƒ©ã‚¹ã®ã‚³ãƒ³ã‚¹ãƒˆãƒ©ã‚¯ã‚¿ã‚’æš—é»™çš„ã«å®£è¨€ã—ã¾ã™ã€‚

```cpp
template <class T>
struct partially_applied_plus_t : __perfect_forward<partially_applied_plus_op, T> {
    using __perfect_forward<partially_applied_plus_op, T>::__perfect_forward;
};
```

## æ‰‹é †3: perfect forwarding call wrapperã‚’ä½¿ã†
æœ€å¾Œã« perfect forwarding call wrapper ã‚’å®£è¨€ã—ã€ä½¿ã£ã¦ã¿ã¾ã™ã€‚[ä¸Šè¨˜](#temp-params-member) ã®é€šã‚Š `T` ã¯ decay ã•ã‚ŒãŸå‹ã‚’ä½¿ã†ã“ã¨ã«æ³¨æ„ã—ã¾ã™ã€‚`std::decay_t<T>` ã®ãƒ†ãƒ³ãƒ—ãƒ¬ãƒ¼ãƒˆå‹åˆ¶ç´„ã¯ (å…ƒã®é–¢æ•°ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆãŒå‘¼ã³å‡ºã—å¯èƒ½ãªæ¡ä»¶ã‚’æº€ãŸã™ã“ã¨ã®ã»ã‹ã«) å°‘ãªãã¨ã‚‚ `T` å‹ã‚ˆã‚Šæ§‹ç¯‰å¯èƒ½ã‹ã¤ãƒ ãƒ¼ãƒ–æ§‹ç¯‰å¯èƒ½ã§ã‚ã‚‹å¿…è¦ãŒã‚ã‚Šã¾ã™ã€‚

```cpp
template <class T, class = std::enable_if_t<
    std::is_constructible_v<std::decay_t<T>, T> &&
    std::is_move_constructible_v<std::decay_t<T>>
>>
constexpr auto partially_applied_plus(T&& t) {
    return partially_applied_plus_t<std::decay_t<T>>(std::forward<T>(t));
}
```

ä»¥ä¸Šã®ã‚³ãƒ¼ãƒ‰ã® [Wandbox ã«ãŠã‘ã‚‹å®Ÿè¡Œçµæœ](https://wandbox.org/permlink/2QoXt9mlgKbv31OM) ã‚’ç½®ã„ã¦ãŠãã¾ã™ã€‚

# ä½¿ç”¨ã®éš›ã®æ³¨æ„ç‚¹
ã‚‚ã†ä¸€åº¦ `operator()` ã®å®Ÿè£…ã‚’ç¤ºã—ã¾ã™ã€‚

```cpp
template <class ...Args, class = std::enable_if_t<std::is_invocable_v<Op, Bound&..., Args...>>>
constexpr auto operator()(Args&&... args) &
    noexcept(noexcept(Op()(std::get<Idx>(bound_)..., std::forward<Args>(args)...)))
    -> decltype(      Op()(std::get<Idx>(bound_)..., std::forward<Args>(args)...))
    { return          Op()(std::get<Idx>(bound_)..., std::forward<Args>(args)...); }
    //                ^~~~ Note!
// ... and other three overloads
```

`Op` ãŒãƒ‡ãƒ•ã‚©ãƒ«ãƒˆæ§‹ç¯‰ã•ã‚Œã¦ã„ã¾ã™ã€‚ã™ãªã‚ã¡ **`Op` ã¯ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆæ§‹ç¯‰å¯èƒ½ã§ãªã‘ã‚Œã°ãªã‚Šã¾ã›ã‚“**ã€‚ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆæ§‹ç¯‰ã§ããªã„é–¢æ•°ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¨ã¯ä½•ã§ã—ã‚‡ã†ã‹ã€‚ãã‚Œã¯ä¾‹ãˆã°ã€**ã‚­ãƒ£ãƒ—ãƒãƒ£ã‚’ã‚‚ã¤ãƒ©ãƒ ãƒ€å¼**ã§ã™ã€‚

C++20 ã‚ˆã‚Šã‚­ãƒ£ãƒ—ãƒãƒ£ã‚’ã‚‚ãŸãªã„ãƒ©ãƒ ãƒ€å¼ãŒãƒ‡ãƒ•ã‚©ãƒ«ãƒˆæ§‹ç¯‰å¯èƒ½ã€ä»£å…¥å¯èƒ½ã¨ãªã‚Šã¾ã—ãŸ[^5] [^6]ã€‚ã•ã‚‰ã«è©•ä¾¡ã•ã‚Œãªã„æ–‡è„ˆã§ã®ãƒ©ãƒ ãƒ€å¼ã®è¨˜è¿°ãŒå¯èƒ½ã¨ãªã‚Šã¾ã—ãŸ[^7] [^8]ã€‚ã—ã‹ã—ã‚­ãƒ£ãƒ—ãƒãƒ£ã‚’ã‚‚ãŸãªã„ã¨ã„ã†åˆ¶ç´„ã‚’å¿˜ã‚Œã‚‹ã¨ã€ä»¥ä¸‹ã®ã‚ˆã†ã«æ›¸ã„ã¦ã—ã¾ã†ã‹ã‚‚ã—ã‚Œã¾ã›ã‚“ã€‚

[^5]: https://wg21.link/p0624 "P0624"
[^6]: https://cpprefjp.github.io/lang/cpp20/default_constructible_and_assignable_stateless_lambdas.html "cpprefjp"
[^7]: https://wg21.link/p0315 "P0315"
[^8]: https://cpprefjp.github.io/lang/cpp20/wording_for_lambdas_in_unevaluated_contexts.html "cpprefjp"

```cpp
// Bad example
template <class Op, class ...Args>
struct perfect_forwarded_t : __perfect_forward<Op, Args...> {
    using __perfect_forward<Op, Args...>::__perfect_forward;
};

int main() {
  using affine_transform_op = decltype([b = 1.0](double a, double x) { return a * x + b; });
  perfect_forwarded_t<affine_transform_op, double> affine_transform(2.0);
  std::cout << affine_transform(3.0) << std::endl; // error!
}
```

ã—ã‹ã—ã“ã®ã‚³ãƒ¼ãƒ‰ã¯ `affine_transform` ã®é–¢æ•°å‘¼ã³å‡ºã—ã«å¤±æ•—ã—ã¾ã™ ([Wandbox ã«ãŠã‘ã‚‹å®Ÿè¡Œçµæœ](https://wandbox.org/permlink/yRUfTlgSpuOpdFZX)) ã€‚ãªãœãªã‚‰**ã‚­ãƒ£ãƒ—ãƒãƒ£ã‚’ã‚‚ã¤ãƒ©ãƒ ãƒ€å¼å‹ã¯ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆæ§‹ç¯‰å¯èƒ½ã§ã¯ãªã„**ã‹ã‚‰ã§ã™ã€‚`operator()` ã®å‘¼ã³å‡ºã—ã®éš› `Op` ã®ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆæ§‹ç¯‰ã«å¤±æ•—ã™ã‚‹ãŸã‚ã€ç›®çš„ã® `operator()` ãŒã‚ªãƒ¼ãƒãƒ¼ãƒ­ãƒ¼ãƒ‰å€™è£œã‹ã‚‰é™¤å¤–ã•ã‚Œã¾ã™ã€‚

# ã¾ã¨ã‚
- libc++ ã® `__perfect_forward` ã¯è‡ªèº«ã® constãƒ»reference ä¿®é£¾ã‚’å®Œå…¨è»¢é€ã™ã‚‹ call wrapper ã‚’å®Ÿç¾ã™ã‚‹ã‚¯ãƒ©ã‚¹ã§ã‚ã‚‹ã€‚
- `__perfect_forward` ã‚’ä½¿ã†éš›ã¯å…ƒã¨ãªã‚‹é–¢æ•°ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆå‹ã‚’ç”¨æ„ã—ã€ `__perfect_forward` ã‚’ç”¨ã„ã¦ perfect forwarding call wrapper å‹ã‚’å®Ÿè£…ã™ã‚‹ã€‚
- `Bound...` ã¯ decay ã•ã‚ŒãŸå‹ã§ã‚ã‚‹å¿…è¦ãŒã‚ã‚‹ã€`Op` ã¯ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆæ§‹ç¯‰å¯èƒ½ã§ã‚ã‚‹å¿…è¦ãŒã‚ã‚‹ã¨ã„ã£ãŸã“ã¨ã«æ³¨æ„ã€‚

# è¬è¾
ã“ã®è¨˜äº‹ã¯ [llvm](https://llvm.org/) ã« inspire ã•ã‚Œã¦æ›¸ã‹ã‚Œã¾ã—ãŸã€‚ã¾ãŸä»¥ä¸‹ã®æ–¹ã€…ã®è¨˜äº‹ã¯æ—¥é ƒã‹ã‚‰å‚è€ƒã«ã•ã›ã¦ã„ãŸã ã„ã¦ãŠã‚Šã¾ã™ã€‚ãŠç¤¼ç”³ã—ä¸Šã’ã¾ã™ (æ•¬ç§°ç•¥) ã€‚

- [yohhoyã®æ—¥è¨˜](https://yohhoy.hatenadiary.jp/)
- [åœ°é¢ã‚’è¦‹ä¸‹ã‚ã™å°‘å¹´ã®è¶³è¹´ã«ã•ã‚Œã‚‹ç§](https://onihusube.hatenablog.com/)
- [@Reputeless](https://twitter.com/Reputeless) ç‰¹ã« [C++ ã®æ­©ãæ–¹ | cppmap](https://cppmap.github.io/)
- [@_EnumHack](https://qiita.com/_EnumHack) ç‰¹ã« [C++ã®ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ãƒ‘ãƒƒã‚¯åŸºç¤&ãƒ‘ãƒƒã‚¯å±•é–‹ãƒ†ã‚¯ãƒ‹ãƒƒã‚¯](https://qiita.com/_EnumHack/items/677363eec054d70b298d)

ã“ã®è¨˜äº‹ãŒç§ã«ã¨ã£ã¦æœ€åˆã®ã‚¢ã‚¦ãƒˆãƒ—ãƒƒãƒˆè¨˜äº‹ã«ãªã‚Šã¾ã™ã€‚è‡³ã‚‰ãªã„ã¨ã“ã‚ãŒã”ã–ã„ã¾ã—ãŸã‚‰ã‚³ãƒ¡ãƒ³ãƒˆé ‚ã‘ã¾ã™ã¨å¹¸ã„ã§ã™ã€‚

æœ€å¾Œã«ã“ã“ã¾ã§ãŠä»˜ãåˆã„ãã ã•ã£ãŸèª­è€…ã®çš†æ§˜ã«æ„Ÿè¬ç”³ã—ä¸Šã’ã¾ã™ã€‚
